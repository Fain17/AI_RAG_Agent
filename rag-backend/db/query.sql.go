// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"

	"github.com/pgvector/pgvector-go"
)

const createFile = `-- name: CreateFile :one
INSERT INTO files (filename, content, embedding)
VALUES ($1, $2, $3)
RETURNING id, filename, content, embedding
`

type CreateFileParams struct {
	Filename  string
	Content   string
	Embedding pgvector.Vector
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile, arg.Filename, arg.Content, arg.Embedding)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Content,
		&i.Embedding,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files WHERE id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFile, id)
	return err
}

const getFile = `-- name: GetFile :one
SELECT id, filename, content, embedding FROM files WHERE id = $1
`

func (q *Queries) GetFile(ctx context.Context, id int32) (File, error) {
	row := q.db.QueryRow(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Content,
		&i.Embedding,
	)
	return i, err
}

const searchFiles = `-- name: SearchFiles :many
SELECT id, filename, content, embedding, embedding <-> $1 AS distance
FROM files
ORDER BY embedding <-> $1
LIMIT $2
`

type SearchFilesParams struct {
	Embedding pgvector.Vector
	Limit     int32
}

type SearchFilesRow struct {
	ID        int32
	Filename  string
	Content   string
	Embedding pgvector.Vector
	Distance  interface{}
}

func (q *Queries) SearchFiles(ctx context.Context, arg SearchFilesParams) ([]SearchFilesRow, error) {
	rows, err := q.db.Query(ctx, searchFiles, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchFilesRow
	for rows.Next() {
		var i SearchFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Content,
			&i.Embedding,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :one
UPDATE files
  SET filename = $2, content = $3, embedding = $4
WHERE id = $1
RETURNING id, filename, content, embedding
`

type UpdateFileParams struct {
	ID        int32
	Filename  string
	Content   string
	Embedding pgvector.Vector
}

func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, updateFile,
		arg.ID,
		arg.Filename,
		arg.Content,
		arg.Embedding,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Content,
		&i.Embedding,
	)
	return i, err
}
